<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「查漏补缺」2020 秋招前端面试经历 | 超逸の博客</title><meta name="description" content="字节跳动广告系统 面经一面自我介绍手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, ini"><meta name="keywords" content="CSS，面试，字节跳动，前端，Vue"><meta name="author" content="Yang Chao Yi"><meta name="copyright" content="Yang Chao Yi"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yangchaoyi.vip/posts/20200812/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="「查漏补缺」2020 秋招前端面试经历"><meta property="og:url" content="https://yangchaoyi.vip/posts/20200812/"><meta property="og:site_name" content="超逸の博客"><meta property="og:description" content="字节跳动广告系统 面经一面自我介绍手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, ini"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200809222241.jpg"><meta property="article:published_time" content="2020-08-28T06:47:04.202Z"><meta property="article:modified_time" content="2020-08-29T11:53:34.008Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="next" title="「斑愿称为最肝」小狮子前端知识食谱 / 生日之际，好运分享 / 秋招和你手摸手入大厂【史上最全指北】" href="https://yangchaoyi.vip/posts/2020812/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-29 19:53:34'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/iconfont.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Chocolate1999/cdn/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fas fa-th-large"></i><span> 聚宝盒</span></a></div><div class="menus_item"><a class="site-page" href="/sponsorWall/"><i class="fa-fw fas fa-money-check-alt"></i><span> 赞助墙</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-coffee"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字节跳动广告系统-面经"><span class="toc-number">1.</span> <span class="toc-text">字节跳动广告系统 面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一面"><span class="toc-number">1.1.</span> <span class="toc-text">一面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自我介绍"><span class="toc-number">1.1.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）"><span class="toc-number">1.1.2.</span> <span class="toc-text">手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS实现三角形"><span class="toc-number">1.1.3.</span> <span class="toc-text">CSS实现三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#盒模型"><span class="toc-number">1.1.4.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue双向绑定实现-Object-defineProperty-它有哪些不足点？"><span class="toc-number">1.1.5.</span> <span class="toc-text">Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-添加单个属性"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 添加单个属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-添加多个属性"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2.添加多个属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#询问输出结果"><span class="toc-number">1.1.6.</span> <span class="toc-text">询问输出结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise相关，下面代码输出结果"><span class="toc-number">1.1.7.</span> <span class="toc-text">promise相关，下面代码输出结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-和-session-区别（session-存放哪）"><span class="toc-number">1.1.8.</span> <span class="toc-text">cookie 和 session 区别（session 存放哪）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#http是一个无状态协议"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">http是一个无状态协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cookie和session"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">cookie和session</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拓展：token"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">拓展：token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#token认证流程"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">token认证流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#token可以抵抗csrf，cookie-session不行"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">token可以抵抗csrf，cookie+session不行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分布式情况下的session和token"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">分布式情况下的session和token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总结"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何保护cookie"><span class="toc-number">1.1.9.</span> <span class="toc-text">如何保护cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Secure和HttpOnly"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">Secure和HttpOnly</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#浏览器设置"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">浏览器设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS中-TLS握手过程简述"><span class="toc-number">1.1.10.</span> <span class="toc-text">HTTPS中 TLS握手过程简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Koa-中间件-passport"><span class="toc-number">1.1.11.</span> <span class="toc-text">Koa 中间件 passport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#仿美团项目登录怎么实现的"><span class="toc-number">1.1.12.</span> <span class="toc-text">仿美团项目登录怎么实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器缓存-强缓存-和-协商缓存-状态码"><span class="toc-number">1.1.13.</span> <span class="toc-text">浏览器缓存 强缓存 和 协商缓存 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结果"><span class="toc-number">1.1.14.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二面"><span class="toc-number">1.2.</span> <span class="toc-text">二面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#腾讯-QQ音乐-面经"><span class="toc-number">2.</span> <span class="toc-text">腾讯 QQ音乐 面经</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一面-1"><span class="toc-number">2.1.</span> <span class="toc-text">一面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自我介绍-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#了解ajax跨域嘛？"><span class="toc-number">2.1.2.</span> <span class="toc-text">了解ajax跨域嘛？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么是跨域"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">什么是跨域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cors跨域怎么做？"><span class="toc-number">2.1.3.</span> <span class="toc-text">cors跨域怎么做？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#简单请求"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#非简单请求"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">非简单请求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说说jsonp原理"><span class="toc-number">2.1.4.</span> <span class="toc-text">说说jsonp原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#拓展：Nginx"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">拓展：Nginx</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果是用node来做跨域的话，你会怎么做？"><span class="toc-number">2.1.5.</span> <span class="toc-text">如果是用node来做跨域的话，你会怎么做？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#先以-express-为例"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">先以 express 为例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#然后，我们再以-koa-为例"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">然后，我们再以 koa 为例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）"><span class="toc-number">2.1.6.</span> <span class="toc-text">怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事件委托-事件代理-的作用"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">事件委托(事件代理)的作用?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件委托和新增节点绑定事件的关系？"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">事件委托和新增节点绑定事件的关系？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？"><span class="toc-number">2.1.7.</span> <span class="toc-text">了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-强缓存"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">1.强缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-协商缓存"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">2.协商缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#既生-Last-Modified-何生-Etag"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">既生 Last-Modified 何生 Etag</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最佳实践"><span class="toc-number">2.1.7.4.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#哈希值计算方式"><span class="toc-number">2.1.7.5.</span> <span class="toc-text">哈希值计算方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补充：后端需要怎么设置"><span class="toc-number">2.1.7.6.</span> <span class="toc-text">补充：后端需要怎么设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP缓存"><span class="toc-number">2.1.7.7.</span> <span class="toc-text">HTTP缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存配置"><span class="toc-number">2.1.7.8.</span> <span class="toc-text">缓存配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cdn缓存"><span class="toc-number">2.1.7.9.</span> <span class="toc-text">cdn缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存规则"><span class="toc-number">2.1.7.10.</span> <span class="toc-text">缓存规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cdn运作流程"><span class="toc-number">2.1.7.11.</span> <span class="toc-text">cdn运作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存配置-1"><span class="toc-number">2.1.7.12.</span> <span class="toc-text">缓存配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#http缓存与cdn缓存的结合"><span class="toc-number">2.1.7.13.</span> <span class="toc-text">http缓存与cdn缓存的结合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window-onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？"><span class="toc-number">2.1.8.</span> <span class="toc-text">如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#script-error-由来"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">script error 由来</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的解决方案"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">常见的解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结果-1"><span class="toc-number">2.1.9.</span> <span class="toc-text">结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阿里智能事业群-达摩院-机器智能技术部"><span class="toc-number">3.</span> <span class="toc-text">阿里智能事业群-达摩院-机器智能技术部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一面-2"><span class="toc-number">3.1.</span> <span class="toc-text">一面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自我介绍-2"><span class="toc-number">3.1.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#聊实习经历"><span class="toc-number">3.1.2.</span> <span class="toc-text">聊实习经历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？"><span class="toc-number">3.1.3.</span> <span class="toc-text">项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对CDN的理解"><span class="toc-number">3.1.4.</span> <span class="toc-text">对CDN的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说一个最近刷的印象比较深刻的-leetcode-题目，讲讲思路"><span class="toc-number">3.1.5.</span> <span class="toc-text">说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大学里面学的一些课程哪门最熟悉？"><span class="toc-number">3.1.6.</span> <span class="toc-text">大学里面学的一些课程哪门最熟悉？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说说五层、七层-计算机网络模型"><span class="toc-number">3.1.7.</span> <span class="toc-text">说说五层、七层 计算机网络模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#举例传输层和应用层"><span class="toc-number">3.1.8.</span> <span class="toc-text">举例传输层和应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-0-和-HTTP2-0区别有了解吗？"><span class="toc-number">3.1.9.</span> <span class="toc-text">HTTP1.0 和 HTTP2.0区别有了解吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><span class="toc-number">3.1.9.1.</span> <span class="toc-text">简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><span class="toc-number">3.1.9.2.</span> <span class="toc-text">HTTP1.1 如何解决 HTTP 的队头阻塞问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-2-有哪些改进？"><span class="toc-number">3.1.9.3.</span> <span class="toc-text">HTTP&#x2F;2 有哪些改进？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-2-中的二进制帧是如何设计的？"><span class="toc-number">3.1.9.4.</span> <span class="toc-text">HTTP&#x2F;2 中的二进制帧是如何设计的？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自己搭的博客目的是什么？主要写的内容是？"><span class="toc-number">3.1.10.</span> <span class="toc-text">自己搭的博客目的是什么？主要写的内容是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#询问了大学里面图像处理课程"><span class="toc-number">3.1.11.</span> <span class="toc-text">询问了大学里面图像处理课程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何学习前端（或者说是如何学习计算机领域知识）"><span class="toc-number">3.1.12.</span> <span class="toc-text">如何学习前端（或者说是如何学习计算机领域知识）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对未来的职业规划"><span class="toc-number">3.1.13.</span> <span class="toc-text">对未来的职业规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有什么问题可以询问"><span class="toc-number">3.1.14.</span> <span class="toc-text">有什么问题可以询问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结果-2"><span class="toc-number">3.1.15.</span> <span class="toc-text">结果</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200809222241.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">超逸の博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fas fa-th-large"></i><span> 聚宝盒</span></a></div><div class="menus_item"><a class="site-page" href="/sponsorWall/"><i class="fa-fw fas fa-money-check-alt"></i><span> 赞助墙</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw far fa-image"></i><span> 相册</span></a></li><li><a class="site-page" href="/home/"><i class="fa-fw fab fa-phoenix-framework"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-coffee"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw far fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">「查漏补缺」2020 秋招前端面试经历</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-28 14:47:04"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-08-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-29 19:53:34"><i class="fas fa-history fa-fw"></i> 更新于 2020-08-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">面试整理</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/posts/20200812/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/posts/20200812/" itemprop="commentCount"></span></a></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="字节跳动广告系统-面经"><a href="#字节跳动广告系统-面经" class="headerlink" title="字节跳动广告系统 面经"></a>字节跳动广告系统 面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）"><a href="#手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）" class="headerlink" title="手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）"></a>手撕防抖（如果滚动条判断一个div是否存在会用什么来做？节流）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">        font-size: 30px;</span><br><span class="line">        line-height: 200px;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'container'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// let cnt = 0</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// let timeId = null</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// btn.onmouseover = () =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//   clearTimeout(timeId)</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//   timeId = setTimeout(() =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//     btn.innerHTML = ++cnt</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">//   &#125;, 2000)</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> cnt = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">        btn.innerHTML = ++cnt</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> debounce = <span class="function">(<span class="params">fn,time,triggerNow</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> timeId = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> debounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line">          if(timeId)&#123;</span><br><span class="line">              clearTimeout(timeId)</span><br><span class="line">            &#125;</span><br><span class="line">          if(triggerNow)&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> exec = !timeId</span></span><br><span class="line"><span class="javascript">            timeId =setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">              timeId = <span class="literal">null</span></span></span><br><span class="line">            &#125;,time)</span><br><span class="line">            if(exec)&#123;</span><br><span class="line"><span class="actionscript">              fn.apply(<span class="keyword">this</span>,args)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            timeId = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">              fn.apply(<span class="keyword">this</span>,args)</span></span><br><span class="line">            &#125;,time)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        debounced.remove = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">          clearTimeout(timeId)</span><br><span class="line"><span class="actionscript">          timeId = <span class="literal">null</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> debounced</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      btn.onmouseover = debounce(doSomething,<span class="number">2000</span>,<span class="literal">false</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="CSS实现三角形"><a href="#CSS实现三角形" class="headerlink" title="CSS实现三角形"></a>CSS实现三角形</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>画三角形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.triggle</span>&#123;</span></span><br><span class="line">            width: 0px;</span><br><span class="line">            height: 0px;</span><br><span class="line">            border-top: 40px solid transparent;</span><br><span class="line">            border-left: 40px solid transparent;</span><br><span class="line">            border-bottom: 40px solid red;</span><br><span class="line">            border-right: 40px solid transparent;</span><br><span class="line">            margin: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"triggle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>: </span><br><span class="line">width=100px;</span><br><span class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">padding</span>: 15<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">height=100px;</span><br><span class="line"></span><br><span class="line">content-box =&gt; 100px</span><br><span class="line"></span><br><span class="line">border-box =&gt; 150px</span><br></pre></td></tr></table></figure>

<h4 id="Vue双向绑定实现-Object-defineProperty-它有哪些不足点？"><a href="#Vue双向绑定实现-Object-defineProperty-它有哪些不足点？" class="headerlink" title="Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？"></a>Vue双向绑定实现 Object.defineProperty()  它有哪些不足点？</h4><ul>
<li>只能监听某个属性，不能对全对象进行监听</li>
<li>需要 for in遍历找对象中的属性</li>
<li>不能监听数组，需要单独的对数组进行特异性操作</li>
<li>会污染原对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data : &#123;</span><br><span class="line">name; <span class="string">'abc'</span>;</span><br><span class="line">age: <span class="number">23</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'brown'</span>;</span><br><span class="line"><span class="keyword">this</span>.gender = <span class="string">'男'</span>;</span><br></pre></td></tr></table></figure>

<p>如何让 gender 改变也会让视图变化（面试官意思是如何用Vue动态新增对象属性,触发dom渲染）</p>
<blockquote>
<p>背景：项目中因为一些需求需要在JSON中新增一个属性,也能console出来,但是就是不能在页面渲染,即不能触发视图更新 </p>
</blockquote>
<p>其实在vue 中新增属性应该用 <code>$set</code> 这个方法的</p>
<h5 id="1-添加单个属性"><a href="#1-添加单个属性" class="headerlink" title="1. 添加单个属性"></a>1. 添加单个属性</h5><p>用 <code>$set()</code>方法，既可以新增属性,又可以触发视图更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(this.data,”key”,value)</span><br></pre></td></tr></table></figure>

<h5 id="2-添加多个属性"><a href="#2-添加多个属性" class="headerlink" title="2.添加多个属性"></a>2.添加多个属性</h5><p>使用 <code>Object.assign()</code>用原对象与要混合进去的对象的属性一起创建一个新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.obj = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.obj, &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  name: <span class="string">'Chocolate'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="询问输出结果"><a href="#询问输出结果" class="headerlink" title="询问输出结果"></a>询问输出结果</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">1</span>); &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">2</span>); &#125;;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">3</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">4</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123; alert(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Foo().getName(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="promise相关，下面代码输出结果"><a href="#promise相关，下面代码输出结果" class="headerlink" title="promise相关，下面代码输出结果"></a>promise相关，下面代码输出结果</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">2</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> e).then(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="cookie-和-session-区别（session-存放哪）"><a href="#cookie-和-session-区别（session-存放哪）" class="headerlink" title="cookie 和 session 区别（session 存放哪）"></a>cookie 和 session 区别（session 存放哪）</h4><h5 id="http是一个无状态协议"><a href="#http是一个无状态协议" class="headerlink" title="http是一个无状态协议"></a>http是一个无状态协议</h5><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把<code>www.zhihu.com/login.html</code> 和 <code>www.zhihu.com/index.html</code>关联起来，必须使用某些手段和工具</p>
<h5 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h5><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下：</p>
<ul>
<li>首先，客户端会发送一个http请求到服务器端。</li>
<li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下：<br><code>Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</code></li>
<li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li>
<li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829103822995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>注意</strong></p>
<ul>
<li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li>
<li><strong>现在大多都是Session + Cookie</strong>，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li>
<li>用session只需要在客户端保存一个id，实际上<strong>大量数据都是保存在服务端</strong>。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li>
<li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li>
</ul>
<h5 id="拓展：token"><a href="#拓展：token" class="headerlink" title="拓展：token"></a>拓展：token</h5><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 <code>REST API</code>（表现层状态转换） 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p>
<p><strong>组成</strong></p>
<ul>
<li>uid: 用户唯一身份标识</li>
<li>time: 当前时间的时间戳</li>
<li>sign: 签名, 使用 <code>hash/encrypt</code> 压缩成定长的十六进制字符串，以防止第三方恶意拼接<br>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li>
</ul>
<p><strong>存放</strong></p>
<p>token在客户端一般存放于<code>localStorage，cookie，或sessionStorage</code>中。在服务器一般存于<code>数据库</code>中</p>
<h5 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h5><p>token 的认证流程与cookie很相似</p>
<ul>
<li>用户登录，成功后服务器返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入<code>headers</code>中</li>
<li>服务器端<strong>采用filter过滤器校验</strong>。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
<h5 id="token可以抵抗csrf，cookie-session不行"><a href="#token可以抵抗csrf，cookie-session不行" class="headerlink" title="token可以抵抗csrf，cookie+session不行"></a>token可以抵抗csrf，cookie+session不行</h5><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为<strong>form 发起的 POST 请求并不受到浏览器同源策略的限制</strong>，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者<strong>为了防范csrf而特别设计的令牌</strong>，浏览器<code>不会自动添加到headers里</code>，攻击者也无法访问用户的token，所以提交的表单<strong>无法通过服务器过滤</strong>，也就无法形成攻击。</p>
<h5 id="分布式情况下的session和token"><a href="#分布式情况下的session和token" class="headerlink" title="分布式情况下的session和token"></a>分布式情况下的session和token</h5><p>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。该解决方案是 <code>session 数据持久化</code>，<strong>写入数据库或别的持久层</strong>。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是<code>工程量比较大</code>。另外，持久层万一挂了，就会单点失败。</p>
<p>而token是无状态的，<code>token</code>字符串里就<strong>保存了所有的用户信息</strong></p>
<p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做<code>JWT(Json Web Token)</code></p>
<blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于<code>分布式站点的单点登录（SSO）场景</code>。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">参考：阮一峰 JSON Web Token 入门教程</a></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session所依赖cookie</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li>
<li>jwt只是一个跨域认证的方案</li>
</ul>
<h4 id="如何保护cookie"><a href="#如何保护cookie" class="headerlink" title="如何保护cookie"></a>如何保护cookie</h4><h5 id="Secure和HttpOnly"><a href="#Secure和HttpOnly" class="headerlink" title="Secure和HttpOnly"></a>Secure和HttpOnly</h5><p><code>Secure</code>属性意味着把cookie通信限制在加密传输中，指示浏览器只能通过安全/加密连接使用cookie。然而如果一个web服务器在非安全连接中给cookie设置了一个secure属性，这个cookie在发送给用户时仍然可以通过<strong>中间人攻击</strong>拦截到。因此，为了安全<strong>必须通过安全连接</strong>设置cookie的Secure属性。</p>
<p><code>HttpOnly</code>属性指示浏览器除了HTTP/HTTPS请求之外不要显示cookie。这意味着这种cookie不能在客户端通过脚本获取，因此也不会轻易的被跨站脚本窃取。</p>
<h5 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h5><p>大部分浏览器都支持cookie，并且允许用户禁止掉他们。下面是一些常用的选项：</p>
<ul>
<li>完全允许或者禁止cookie，以便浏览器总是接受或者总是阻止cookie</li>
<li>通过cookie管理器查看或者删除cookie</li>
<li>彻底清除所有的隐私数据，包括cookie</li>
</ul>
<h4 id="HTTPS中-TLS握手过程简述"><a href="#HTTPS中-TLS握手过程简述" class="headerlink" title="HTTPS中 TLS握手过程简述"></a>HTTPS中 TLS握手过程简述</h4><p><a href="http://47.98.159.95/my_blog/browser-security/003.html" target="_blank" rel="noopener">参考：三元博客 (传统RSA版本)HTTPS为什么让数据传输更安全？</a></p>
<p><a href="https://juejin.im/post/6844904100035821575#heading-74" target="_blank" rel="noopener">参考：TLS1.2 握手的过程是怎样的？</a></p>
<h4 id="Koa-中间件-passport"><a href="#Koa-中间件-passport" class="headerlink" title="Koa 中间件 passport"></a>Koa 中间件 passport</h4><h4 id="仿美团项目登录怎么实现的"><a href="#仿美团项目登录怎么实现的" class="headerlink" title="仿美团项目登录怎么实现的"></a>仿美团项目登录怎么实现的</h4><h4 id="浏览器缓存-强缓存-和-协商缓存-状态码"><a href="#浏览器缓存-强缓存-和-协商缓存-状态码" class="headerlink" title="浏览器缓存 强缓存 和 协商缓存 状态码"></a>浏览器缓存 强缓存 和 协商缓存 状态码</h4><blockquote>
<p>（见后文）</p>
</blockquote>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>一面通过</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>待更新…</p>
<h2 id="腾讯-QQ音乐-面经"><a href="#腾讯-QQ音乐-面经" class="headerlink" title="腾讯 QQ音乐 面经"></a>腾讯 QQ音乐 面经</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><h4 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="了解ajax跨域嘛？"><a href="#了解ajax跨域嘛？" class="headerlink" title="了解ajax跨域嘛？"></a>了解ajax跨域嘛？</h4><h5 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h5><p>回顾一下 URI 的组成:</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828151935234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>浏览器遵循<strong>同源政策</strong>(<code>scheme(协议)</code>、<code>host(主机)</code> 和 <code>port(端口)</code> 都相同则为同源)。非同源站点有这样一些限制:</p>
<ul>
<li>不能读取和修改对方的 DOM</li>
<li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li>
<li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li>
</ul>
<p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为 <code>跨域请求。</code></p>
<p>跨域请求的响应一般会被浏览器所拦截，注意，是被<strong>浏览器</strong>拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？</p>
<p>首先要知道的是，浏览器是多进程的，以 <code>Chrome</code> 为例，进程组成如下：</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020082817450440.png#pic_center" alt=""><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828152201813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>WebKit 渲染引擎</strong> 和 <strong>V8 引擎</strong>都在渲染进程当中。</p>
<p>当 <code>xhr.send</code> 被调用，即 <code>Ajax</code> 请求准备发送的时候，其实还只是在<strong>渲染进程</strong>的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的Spectre 和 Meltdown漏洞，采取了站点隔离的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。具体见<a href="https://www.youtube.com/watch?v=dBuykrdhK-A&feature=emb_logo" target="_blank" rel="noopener">YouTube上Chromium安全团队的演讲视频</a>。</p>
<p>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到<strong>进程间通信</strong>(IPC，Inter Process Communication)了。</p>
<blockquote>
<p>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。</p>
</blockquote>
<p>好，现在数据传递给了<strong>浏览器主进程</strong>，主进程接收到后，才真正地发出相应的网络请求。<br>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有<code>cors</code>(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。</p>
<h4 id="cors跨域怎么做？"><a href="#cors跨域怎么做？" class="headerlink" title="cors跨域怎么做？"></a>cors跨域怎么做？</h4><p>CORS 其实是 W3C 的一个标准，全称是 <code>跨域资源共享</code> 。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: <strong>简单请求</strong>和<strong>非简单请求</strong>。</p>
<p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于<strong>简单请求</strong>:</p>
<ul>
<li>请求方法为 GET、POST 或者 HEAD</li>
<li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code> 、<code>multipart/form-data</code> 、<code>text/plain</code>)</li>
</ul>
<p>浏览器画了这样一个圈，在这个圈里面的就是<strong>简单请求</strong>, 圈外面的就是<strong>非简单请求</strong>，然后针对这两种不同的请求进行不同的处理。</p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>请求发出去之前，浏览器做了什么？</p>
<p>它会自动在请求头当中，添加一个<code>Origin</code>字段，用来说明请求来自哪个<code>源</code>。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果<code>Origin</code>不在这个字段的范围中，那么浏览器就会将响应拦截。</p>
<p>因此，<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p>
<p><strong>Access-Control-Allow-Credentials</strong>。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段<strong>默认值</strong>设为 <code>false</code>，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为<code>true</code>, 并且在前端也需要设置<code>withCredentials</code>属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Access-Control-Expose-Headers</strong>。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified 和 Pragma</code>）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Expose-Headers: aaa</span><br></pre></td></tr></table></figure>
<p>那么在前端可以通过 <code>XMLHttpRequest.getResponseHeader(&#39;aaa&#39;)</code>拿到 <code>aaa</code> 这个字段的值。</p>
<h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>非简单请求相对而言会有些不同，体现在两个方面: <strong>预检请求</strong>和<strong>响应字段</strong>。</p>
<p>我们以 PUT 方法为例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://xxx.com'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>当这段代码执行后，首先会发送<strong>预检请求</strong>。这个预检请求的请求行和请求体是下面这个格式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OPTIONS / HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: 当前地址</span><br><span class="line">Host: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>

<p>预检请求的方法是 <code>OPTIONS</code>，同时会加上<code>Origin</code>源地址和<code>Host</code>目标地址，这很简单。同时也会加上两个关键的字段:</p>
<ul>
<li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li>
<li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li>
</ul>
<p>这是<code>预检请求</code>。接下来是<strong>响应字段</strong>，响应字段也分为两部分，一部分是对于<strong>预检请求</strong>的响应，一部分是对于 <strong>CORS 请求</strong>的响应。</p>
<p><strong>预检请求的响应</strong>。如下面的格式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>其中有这样几个关键的<strong>响应头字段</strong>:</p>
<ul>
<li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</li>
<li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li>
<li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li>
<li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li>
<li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li>
</ul>
<p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS</strong>请求也不会发出去了。</p>
<p><strong>CORS 请求的响应</strong>。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和<strong>简单请求</strong>的情况是一样的。浏览器自动加上<code>Origin</code>字段，服务端响应头返回<strong>Access-Control-Allow-Origin</strong>。可以参考以上简单请求部分的内容。</p>
<h4 id="说说jsonp原理"><a href="#说说jsonp原理" class="headerlink" title="说说jsonp原理"></a>说说jsonp原理</h4><p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义封装jsonp */</span></span><br><span class="line"><span class="keyword">let</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> generateUrl = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElemet(<span class="string">'script'</span>)</span><br><span class="line">    script.src = generateUrl</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然在服务端也会有响应的操作, 以 <strong>express</strong> 为例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 服务端相关操作，以express为例 */</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="string">'3000'</span></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;a,b,callback&#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">  <span class="comment">// 注意，返回给script标签，浏览器直接把这部分字符串执行</span></span><br><span class="line">  res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('数据包')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app;listen(port)</span><br></pre></td></tr></table></figure>

<p>前端这样简单地调用一下就好了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前端调用 */</span></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">//该数据包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p>
<h5 id="拓展：Nginx"><a href="#拓展：Nginx" class="headerlink" title="拓展：Nginx"></a>拓展：Nginx</h5><p><code>Nginx</code> 是一种高性能的 <code>反向代理</code> 服务器，可以用来轻松解决跨域问题。</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828165451492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p>
<p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后<strong>选择一个合适</strong>的服务器，将请求转交给它。</p>
<p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p>
<p>好了，那 <code>Nginx</code> 是如何来解决跨域的呢？</p>
<p>比如说现在客户端的域名为 <code>client.com</code>，服务器的域名为 <code>server.com</code>，客户端向服务器发送 <code>Ajax</code> 请求，当然会跨域了，那这个时候让 <code>Nginx</code> 登场了，通过下面这个配置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是 <code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给 <code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p>
<blockquote>
<p>还有一些不太常用的方式，了解即可，比如postMessage，当然WebSocket也是一种方式，但是已经不属于 HTTP 的范畴。</p>
</blockquote>
<h4 id="如果是用node来做跨域的话，你会怎么做？"><a href="#如果是用node来做跨域的话，你会怎么做？" class="headerlink" title="如果是用node来做跨域的话，你会怎么做？"></a>如果是用node来做跨域的话，你会怎么做？</h4><blockquote>
<p>(1) 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了<br>CORS，就实现了跨域。<br>(2) 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访<br>问资源，如果设置通配符(*)则表示所有网站都可以访问资源。<br>(3)设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分<br>别为简单请求和复杂请求。（上文已经提到）</p>
</blockquote>
<h5 id="先以-express-为例"><a href="#先以-express-为例" class="headerlink" title="先以 express 为例"></a>先以 <code>express</code> 为例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allow custom header and CORS</span></span><br><span class="line">app.all(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.send(<span class="number">200</span>); <span class="regexp">/让options请求快速返回/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>介绍一个 <code>cors</code> 模块,引入就可以解决了。代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* express引入cors模块 */</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> cors = <span class="built_in">require</span>(<span class="string">'cors'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/products/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.json(&#123; <span class="attr">msg</span>: <span class="string">'This is CORS-enabled for all origins!'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CORS-enabled web server listening on port 80'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="然后，我们再以-koa-为例"><a href="#然后，我们再以-koa-为例" class="headerlink" title="然后，我们再以 koa 为例"></a>然后，我们再以 <code>koa</code> 为例</h5><p><strong>服务端: 3001端口</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser()); <span class="comment">// 解析body数据</span></span><br><span class="line">router.options(<span class="string">'/test'</span>,<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type"</span>);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.set(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">  ctx.status = <span class="number">204</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.post(<span class="string">'/test'</span>,<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ctx.router available</span></span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type"</span>);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  ctx.set(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.set(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    status: <span class="string">'success'</span>,</span><br><span class="line">    result: ctx.request.body</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(router.routes())</span><br><span class="line">  .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>

<p><strong>客户端:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;测试&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    fetch(<span class="string">'http://localhost:3001/test'</span>, &#123;</span><br><span class="line">      method: <span class="string">'POST'</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=utf-8'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        data: <span class="string">'Test'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>koa</code> 也有个 <code>cors</code> 模块.代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* koa引入cors模块 */</span></span><br><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">var</span> route = <span class="built_in">require</span>(<span class="string">'koa-route'</span>)</span><br><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">'koa-cors'</span>)</span><br><span class="line"><span class="keyword">var</span> app = koa()</span><br><span class="line"></span><br><span class="line">app.use(cors())</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  route.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.body = &#123; <span class="attr">msg</span>: <span class="string">'Hello World!'</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）"><a href="#怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）" class="headerlink" title="怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）"></a>怎样给一个新增的dom节点绑定事件？（询问事件代理的作用）</h4><h5 id="事件委托-事件代理-的作用"><a href="#事件委托-事件代理-的作用" class="headerlink" title="事件委托(事件代理)的作用?"></a>事件委托(事件代理)的作用?</h5><ul>
<li>支持为同一个DOM元素注册多个同类型事件</li>
<li>可将事件分成事件捕获和事件冒泡机制</li>
</ul>
<p><strong>注册多个事件</strong></p>
<blockquote>
<p>用以往注册事件的方法,如果存在多个事件,后注册的事件会覆盖先注册的事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.html</span></span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">window.onload = function()&#123;</span></span><br><span class="line"><span class="regexp">    let div1 = document.getElementById('div1');</span></span><br><span class="line"><span class="regexp">    div1.onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('打印第一次')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    div1.onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('打印第二次')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828191356247.png#pic_center" alt=""></p>
<blockquote>
<p>可以看到第二个点击注册事件覆盖了第一个注册事件,只执行了console.log(‘打印第二次’);</p>
</blockquote>
<p>用 <code>addEventListener(type,listener,useCapture)</code>实现</p>
<ul>
<li>type: 必须,String类型,事件类型</li>
<li>listener: 必须,函数体或者JS方法</li>
<li>useCapture: 可选,boolean类型。指定事件是否发生在捕获阶段。<strong>默认</strong>为false,事件发生在<strong>冒泡</strong>阶段</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">window.onload = function()&#123;</span></span><br><span class="line"><span class="regexp">    let div1 = document.getElementById('div1');</span></span><br><span class="line"><span class="regexp">    div1.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('打印第一次')</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">    div1.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('打印第二次')</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828191501273.png#pic_center" alt=""></p>
<blockquote>
<p>可以看到两个注册事件都成功触发了。 useCapture是事件委托的关键,我们后面详解</p>
</blockquote>
<p><strong>事件捕获和事件冒泡机制</strong></p>
<p>事件捕获</p>
<p>当一个事件触发后,从Window对象触发,不断<strong>经过下级节点,直到目标节点</strong>。在事件到达目标节点之前的过程就是捕获阶段。<code>所有经过的节点,都会触发对应的事件</code></p>
<p>事件冒泡</p>
<p>当事件到达目标节点后，会<strong>沿着捕获阶段的路线原路返回</strong>。同样，<code>所有经过的节点,都会触发对应的事件</code></p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828191703820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>通过例子理解两个事件机制:<br>例子：假设有body和body节点下的div1均有绑定了一个注册事件.<br>效果：</p>
<ul>
<li>当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件<ul>
<li>当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当useCapture为默认false时,为事件冒泡</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"div1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果:打印div1  打印body</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828191807616.png#pic_center" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当useCapture为true时,为事件捕获</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"div1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span><br><span class="line">    &#125;,<span class="literal">true</span>)</span><br><span class="line">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:打印body   打印div1</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828191818232.png#pic_center" alt=""></p>
<h5 id="事件委托和新增节点绑定事件的关系？"><a href="#事件委托和新增节点绑定事件的关系？" class="headerlink" title="事件委托和新增节点绑定事件的关系？"></a>事件委托和新增节点绑定事件的关系？</h5><p>事件委托的优点:</p>
<ul>
<li><strong>提高性能</strong>: 每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。</li>
<li><strong>动态监听</strong>: 使用事件委托可以<strong>自动绑定动态添加的元素</strong>,即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</li>
</ul>
<p>例子解析:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span><br><span class="line">        </span><br><span class="line">        div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e.target)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> div3 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        div3.setAttribute(<span class="string">'class'</span>,<span class="string">'div3'</span>)</span><br><span class="line">        div3.innerHTML = <span class="string">'div3'</span>;</span><br><span class="line">        div.appendChild(div3)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="div"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="div1"&gt;div1&lt;/</span>div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div2"</span>&gt;div2&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然没有给div1和div2添加点击事件,但是无论是点击div1还是div2,都会打印当前节点。因为其父级绑定了点击事件,点击div1后冒泡上去的时候,执行父级的事件。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200828192241244.png#pic_center" alt=""></p>
<blockquote>
<p>这样无论后代新增了多少个节点,一样具有这个点击事件的功能。</p>
</blockquote>
<h4 id="了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？"><a href="#了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？" class="headerlink" title="了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？"></a>了解浏览器缓存吗？（强缓存、协商缓存）你怎样更新强缓存呢？</h4><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829085756205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h5 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1.强缓存"></a>1.强缓存</h5><p>强缓存是指直接通过本地缓存获取资源，不用经过服务器</p>
<p>常用字段：</p>
<ul>
<li>expires<br>值为一个绝对时间的 GMT 格式的时间字符串，如果发送请求的时间在 expires 之前，那么本地缓存有效，否则就会发送请求到服务器来获取资源。</li>
</ul>
<p>缺点：无法保证客户端按照标准时间设定</p>
<ul>
<li>Cache-Control(常用值如下)：</li>
</ul>
<p>max-age：允许的最大缓存秒数<br>no-store：不允许使用缓存，<strong>每次都要向服务器获取</strong><br>no-cache：不允许使用本地缓存，<strong>每次都要向服务器进行协商缓存</strong><br>public：允许被<strong>所有</strong>中间代理和终端浏览器缓存<br>private：只允许被终端浏览器缓存<br>Cache-Control 比 expires 优先级高</p>
<h5 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2.协商缓存"></a>2.协商缓存</h5><p>协商缓存是指客户端<strong>向服务端确认资源是否用</strong></p>
<p>常用字段：</p>
<ul>
<li>Last-Modified / If-Modified-Since：</li>
</ul>
<p>值是 GMT 格式的时间字符串，具体流程如下：</p>
<p>浏览器第一次请求资源，服务端返回 <code>Last-Modified</code>，表示资源在服务端的最后修改时间。<br>浏览器第二次请求的时候会在请求头上携带<code>If-Modified-Since</code>，值为上次返回的 <code>Last-Modified</code><br>服务端收到请求后，比较保存的 <code>Last-Modified</code> 和 请求报文中的 <code>If-Modified-Since</code>，如果一致就返回 304 状态码，不一致就返回新资源，同时更新 <code>Last-Modified</code> 值</p>
<ul>
<li>ETag / If-None-Match</li>
</ul>
<p>值是服务器生成的资源标识符，当资源修改后这个值会被改变，</p>
<p>具体流程与 <code>Last-Modified、If-Modified-Since</code> 相似，但与 <code>Last-Modified</code> 不一样的是，当服务器返回304的响应时，由于 ETag 重新生成过，<code>response header</code>中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>
<h5 id="既生-Last-Modified-何生-Etag"><a href="#既生-Last-Modified-何生-Etag" class="headerlink" title="既生 Last-Modified 何生 Etag"></a>既生 Last-Modified 何生 Etag</h5><ul>
<li><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，我们就可以使用 <code>Etag</code> 来做</p>
</li>
<li><p>某些文件修改非常频繁，比如在<strong>秒以下的时间内</strong>进行修改，(比方说1s内修改了N次)，<code>If-Modified-Since</code> 能检查到的粒度是s级的，这种修改无法判断</p>
</li>
</ul>
<h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><blockquote>
<p>缓存的意义就在于<code>减少请求</code>，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。</p>
</blockquote>
<p>在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便<strong>把静态资源的路径</strong>改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829085935300.png#pic_center" alt=""><br>伟大的<strong>webpack</strong>可以让我们在打包的时候，在文件的命名上带上 <code>hash</code> 值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    main: path.join(__dirname,<span class="string">'./main.js'</span>),</span><br><span class="line">    vendor: [<span class="string">'react'</span>, <span class="string">'antd'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,<span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filname: <span class="string">'bundle.[chunkhash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，我们可以得出一个较为合理的缓存方案：</p>
<ul>
<li>HTML：使用协商缓存。</li>
<li>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。</li>
</ul>
<h5 id="哈希值计算方式"><a href="#哈希值计算方式" class="headerlink" title="哈希值计算方式"></a>哈希值计算方式</h5><p>webpack给我们提供了三种哈希值计算方式，分别是 <code>hash</code> 、<code>chunkhash</code> 和 <code>contenthash</code>。那么这三者有什么区别呢？</p>
<ul>
<li>hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。</li>
<li>chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。</li>
<li>contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。</li>
</ul>
<blockquote>
<p>显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的hash都变了，缓存自然都失效了。这不是我们想要的。</p>
</blockquote>
<p>那<code>chunkhash</code> 和 <code>contenthash</code> 的主要应用场景是什么呢？在实际在项目中，我们一般会把项目中的<code>css</code>都抽离出对应的<strong>css文件</strong>来加以引用。如果我们使用chunkhash，当我们改了css代码之后，会发现css文件hash值改变的同时，js文件的hash值也会改变。这时候，contenthash就派上用场了。</p>
<h5 id="补充：后端需要怎么设置"><a href="#补充：后端需要怎么设置" class="headerlink" title="补充：后端需要怎么设置"></a>补充：后端需要怎么设置</h5><p>上文主要说的是前端如何进行打包，那后端怎么做呢？ 我们知道，浏览器是根据响应头的相关字段来决定缓存的方案的。所以，后端的关键就在于，根据不同的请求返回对应的缓存字段。 以<code>nodejs</code>为例，如果<strong>需要浏览器强缓存</strong>，我们可以这样设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age=xxx'</span>);</span><br></pre></td></tr></table></figure>

<p>如果需要协商缓存，则可以这样设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age=0'</span>);</span><br><span class="line">res.setHeader(<span class="string">'Last-Modified'</span>, xxx);</span><br><span class="line">res.setHeader(<span class="string">'ETag'</span>, xxx);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。</p>
</blockquote>
<h5 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h5><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020082909125616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><p>方案如下：</p>
<ul>
<li>方案1：cache-control: no-store：不缓存，每次访问都从服务下载所有资源。</li>
<li>方案2：cache-control: no-cache或cache-control: max-age=0：对比缓存，缓存当前资源，但每次访问都需要跟服务器对比，检查资源是否被修改。（等同于expires = 过去的时间或无效时间，缓存但立即过期）</li>
<li>方案3：cache-control: max-age=seconds //seconds &gt; 0：强缓存，缓存当前资源，在一定时期内，再次请求资源直接读取本地缓存。</li>
</ul>
<blockquote>
<p>注：强缓存下资源也并非不可更新，例如chrome的<code>ctrl + f5</code>等同于直接触发方案1，f5或者webview的刷新键会直接触发方案2，但都是基于客户端操作，不建议纳入实际项目考虑。</p>
</blockquote>
<blockquote>
<p>实际项目中，方案1的应用基本上看不到，对比方案2和方案3，方案1没有任何优势。在方案2和方案3的选择中，我们会对资源作区分。</p>
</blockquote>
<ul>
<li><p>对于<code>img，css，js，fonts</code>等非html资源，我们可以直接考虑方案3，并且max-age配置的时间可以尽可能久，类似于缓存规则案例中，<code>cache-control: max-age=31535000</code> 配置365天的缓存，需要注意的是，这样配置并不代表这些资源就一定一年不变，其根本原因在于目前前端构建工具在静态资源中都会加入戳的概念（例如，webpack中的[hash]，gulp中的gulp-rev），<strong>每次修改均会改变文件名或增加query参数，本质上改变了请求的地址</strong>，也就不存在缓存更新的问题。</p>
</li>
<li><p>对于<code>html</code>资源，我们建议根据项目的更新频度来确定采用哪套方案。html作为前端资源的入口文件，一旦被强缓存，那么相关的js，css，img等均无法更新。对于<strong>高频维护的业务类</strong>项目，建议采用方案2，或是方案3但max-age设置一个较小值，例如3600，一小时过期。对于一些活动项目，上线后<strong>不会进行较大改动，建议采用方案3</strong>，不过max-age也不要设置过大，否则一旦出现bug或是未知问题，用户无法及时更新。</p>
</li>
</ul>
<blockquote>
<p>除了以上考虑，有时候其他因素也会影响缓存的配置，例如<code>QQ红包除夕活动</code>，高并发大流量很容易给服务器带来极大挑战，这时我们作为前端开发，就可以采用方案3来避免用户多次进入带来的流量压力。</p>
</blockquote>
<blockquote>
<p>对于http缓存的配置，我们始终要做到两点，一是清楚明白http缓存的原理与规则，二是明确<code>缓存的配置不是一次性的</code>，根据不同的情况配置不同的规则，才能够更好的发挥http缓存的价值。</p>
</blockquote>
<h5 id="cdn缓存"><a href="#cdn缓存" class="headerlink" title="cdn缓存"></a>cdn缓存</h5><blockquote>
<p>cdn缓存是一种服务端缓存，CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上，当用户访问相应的业务资源时，用户会被调度至最接近的节点最近的节点ip返回给用户，在web性能优化中，它主要起到了，缓解源站压力，优化不同用户的访问速度与体验的作用。</p>
</blockquote>
<h5 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h5><p>与http缓存规则不同的是，这个规则并不是规范性的，而是由cdn服务商来制定，我们以腾讯云举例，打开cdn加速服务配置，面板如下。</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829093146111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>可以看到，提供给我们的配置项只有文件类型（或文件目录）和刷新时间，意义也很简单，针对不同文件类型，在cdn节点上缓存对应的时间。</p>
<h5 id="cdn运作流程"><a href="#cdn运作流程" class="headerlink" title="cdn运作流程"></a>cdn运作流程</h5><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829093208366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>由图我们可以看出，cdn缓存的配置主要作用在缓存处理阶段，虽然配置项只有文件类型和缓存时间，但流程却并不简单，我们先来明确一个概念——<strong>回源</strong>，回源的意思就是<strong>返回源站，何为源站，就是我们自己的服务器</strong>，很多人误解接入cdn就是把资源放在了cdn上，其实不然，如图中所示，接入cdn后，我们的服务器就是源站，源站一般情况下只会在cdn节点没有资源或cdn资源失效时接收到cdn节点的请求，其他时间，源站并不会接收请求（当然，如果我们知道源站的地址，我们可以直接访问源站）。明确了回源的概念后，cdn的流程就显得不那么复杂了，简单的理解就是， <strong>没有资源就去源站读取，有资源就直接发送给用户。</strong> 与http缓存不同的是，cdn中没有no-cache（max-age=0）的情况，当我们设置缓存时间为0的时候，该类型文件就被认定为不缓存文件，就是所有请求直接转发源站，<strong>只有当缓存时间大于0且缓存过期的时候，才会与源站对比缓存是否被修改。</strong></p>
<h5 id="缓存配置-1"><a href="#缓存配置-1" class="headerlink" title="缓存配置"></a>缓存配置</h5><blockquote>
<p>各个cdn服务商并不完全一致，以腾讯云为例，在缓存配置的文档中特别有以下说明。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829093344364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>这会对我们有什么影响呢？</p>
<ul>
<li><p>如果我们http缓存设置cache-control: max-age=600，即缓存10分钟，但cdn缓存配置中设置文件缓存时间为1小时，那么就会出现如下情况，文件被访问后第12分钟修改并上传到服务器，用户重新访问资源，响应码会是304，对比缓存未修改，资源依然是旧的，一个小时后再次访问才能更新为最新资源</p>
</li>
<li><p>如果不设置cache-control呢，在http缓存中我们说过，如果不设置cache-control，那么会有默认的缓存时间，但在这里，cdn服务商明确会在没有cache-control字段时主动帮我们添加cache-control: max-age=600。</p>
</li>
</ul>
<p>注：针对问题1，也并非没有办法，当我们必须要在缓存期内修改文件，并且不想影响用户体验，那么我们可以<strong>使用cdn服务商提供的强制更新缓存功能</strong>，主要注意的是，这里的强制更新是更新服务端缓存，<strong>http缓存</strong>依然按照http头部规则进行自己的缓存处理，并<strong>不会受到影响</strong>。</p>
<h5 id="http缓存与cdn缓存的结合"><a href="#http缓存与cdn缓存的结合" class="headerlink" title="http缓存与cdn缓存的结合"></a>http缓存与cdn缓存的结合</h5><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829093529114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>当用户访问我们的业务服务器时，首先进行的就是http缓存处理，如果http缓存通过校验，则直接响应给用户，如果<strong>未通过校验，则继续进行cdn缓存</strong>的处理，cdn缓存处理完成后返回给客户端，由客户端进行http缓存规则存储并响应给用户。</p>
<h4 id="如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window-onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？"><a href="#如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window-onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？" class="headerlink" title="如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？"></a>如何检测JS错误，如何保证你的产品质量？（错误监控）（仅仅答了window.onerror）跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</h4><h5 id="script-error-由来"><a href="#script-error-由来" class="headerlink" title="script error 由来"></a>script error 由来</h5><p>我们的页面往往将静态资源（ js、css、image ）存放到第三方 CDN，或者依赖于外部的静态资源。当从<strong>第三方加载的 javascript 执行出错</strong>时，由于同源策略，为了<code>保证用户信息不被泄露，不会返回详细的错误信息</code>，取之返回 script error。</p>
<p>webkit 源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool ScriptExecutionContext::sanitizeScriptError(<span class="built_in">String</span>&amp; errorMessage, int&amp; lineNumber, <span class="built_in">String</span>&amp; sourceURL) &#123;</span><br><span class="line">  KURL targetURL = completeURL(sourceURL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (securityOrigin()-&gt;canRequest(targetURL)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 非同源，将相关的错误信息设置成默认，错误信息置为 Script error，行号置成0</span></span><br><span class="line">  errorMessage = <span class="string">"Script error."</span>;</span><br><span class="line">  sourceURL = <span class="built_in">String</span>();</span><br><span class="line">  ineNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ScriptExecutionContext::dispatchErrorEvent(<span class="keyword">const</span> <span class="built_in">String</span>&amp; errorMessage, int lineNumber, <span class="keyword">const</span> <span class="built_in">String</span>&amp; sourceURL) &#123;</span><br><span class="line">  EventTarget* target = errorEventTarget();</span><br><span class="line">  <span class="keyword">if</span> (!target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">String</span> message = errorMessage;</span><br><span class="line">  int line = lineNumber;</span><br><span class="line">  <span class="built_in">String</span> sourceName = sourceURL;</span><br><span class="line">  sanitizeScriptError(message, line, sourceName);</span><br><span class="line">  ASSERT(!m_inDispatchErrorEvent);</span><br><span class="line">  m_inDispatchErrorEvent = <span class="literal">true</span>;</span><br><span class="line">  RefPtr&lt;ErrorEvent&gt; errorEvent = ErrorEvent::create(message, sourceName, line);</span><br><span class="line">  target-&gt;dispatchEvent(errorEvent);</span><br><span class="line">  m_inDispatchErrorEvent = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> errorEvent-&gt;defaultPrevented();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见的解决方案"><a href="#常见的解决方案" class="headerlink" title="常见的解决方案"></a>常见的解决方案</h5><ul>
<li>开启 CORS 跨域资源共享</li>
</ul>
<p>a) 添加 crossorigin=”anonymous” 属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://domain/path/*.js"</span> crossorigin=<span class="string">"anonymous"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>当有 crossorigin=”anonymous”，浏览器以匿名的方式获取目标脚本，请求脚本时不会向服务器发送用户信息（ cookie、http 证书等）。</p>
<p>b) 此时静态服务器需要添加跨域协议头：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>完成这两步后 <code>window.onerror</code> 就能够捕获对应跨域脚本发生错误时的详细错误信息了。</p>
<ul>
<li>try catch</li>
</ul>
<blockquote>
<p>crossorigin=”anonymous” 确实可以完美解决 badjs 上报 script error 问题，但是需要服务端进行跨域头支持，而往往在大型企业，域名多的令人发指，导致跨域规则配置非常复杂，所以很难全部都配置上，而且依赖的一些外部资源也不能确保支持，所以我们在<code>调用外部资源方法以及一些不确认是否配置跨域头的资源方法时采用 try catch 包装，并在 catch 到问题时上报对应的错误</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reportBadjs(e); <span class="comment">// report the error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/6844904024441880589#heading-1" target="_blank" rel="noopener">参考：前端 JavaScript 错误分析实践</a></p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>一面凉经，继续努力。</p>
<h2 id="阿里智能事业群-达摩院-机器智能技术部"><a href="#阿里智能事业群-达摩院-机器智能技术部" class="headerlink" title="阿里智能事业群-达摩院-机器智能技术部"></a>阿里智能事业群-达摩院-机器智能技术部</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><h4 id="自我介绍-2"><a href="#自我介绍-2" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="聊实习经历"><a href="#聊实习经历" class="headerlink" title="聊实习经历"></a>聊实习经历</h4><blockquote>
<p>主要工作内容，比如申请前端小组组长，与项目负责人沟通，完成模块发布工具前端框架。每日完成工作进度汇报，前端工作主要是表格页面渲染，比如树形表格，分组表格结合等，实现基本的增删改查功能…</p>
</blockquote>
<h4 id="项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？"><a href="#项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？" class="headerlink" title="项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？"></a>项目中有用到SSR，说说对SSR的理解，目前为什么要用SSR？</h4><h4 id="对CDN的理解"><a href="#对CDN的理解" class="headerlink" title="对CDN的理解"></a>对CDN的理解</h4><blockquote>
<p>github 里面有做cdn仓库，于是扯到了cdn，之后挂钩上http缓存，浏览器缓存相关，回源那一块。</p>
</blockquote>
<h4 id="说一个最近刷的印象比较深刻的-leetcode-题目，讲讲思路"><a href="#说一个最近刷的印象比较深刻的-leetcode-题目，讲讲思路" class="headerlink" title="说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路"></a>说一个最近刷的印象比较深刻的 leetcode 题目，讲讲思路</h4><blockquote>
<p>leetcode 200 岛屿问题 讲了怎么dfs 沉岛</p>
</blockquote>
<h4 id="大学里面学的一些课程哪门最熟悉？"><a href="#大学里面学的一些课程哪门最熟悉？" class="headerlink" title="大学里面学的一些课程哪门最熟悉？"></a>大学里面学的一些课程哪门最熟悉？</h4><blockquote>
<p>算法、数据结构、计算机网络、操作系统</p>
</blockquote>
<p>选了计算机网络，毕竟是班主任教的（orz）</p>
<h4 id="说说五层、七层-计算机网络模型"><a href="#说说五层、七层-计算机网络模型" class="headerlink" title="说说五层、七层 计算机网络模型"></a>说说五层、七层 计算机网络模型</h4><p><a href="https://juejin.im/post/6861131647056805902" target="_blank" rel="noopener">参考：详解 四层、五层、七层 计算机网络模型</a></p>
<h4 id="举例传输层和应用层"><a href="#举例传输层和应用层" class="headerlink" title="举例传输层和应用层"></a>举例传输层和应用层</h4><p>传输层：TCP / UDP<br>应用层：HTTP / HTTPS 、FTP、SMTP等</p>
<h4 id="HTTP1-0-和-HTTP2-0区别有了解吗？"><a href="#HTTP1-0-和-HTTP2-0区别有了解吗？" class="headerlink" title="HTTP1.0 和 HTTP2.0区别有了解吗？"></a>HTTP1.0 和 HTTP2.0区别有了解吗？</h4><h5 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h5><p><strong>HTTP 特点</strong></p>
<ul>
<li><p>灵活可扩展<br>主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p>
</li>
<li><p>可靠传输<br>HTTP 基于 TCP/IP，因此把这一特性继承了下来。</p>
</li>
<li><p>请求-应答<br>也就是<code>一发一收、有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p>
</li>
<li><p>无状态<br>这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p>
</li>
</ul>
<p><strong>HTTP 缺点</strong></p>
<ul>
<li>无状态</li>
</ul>
<p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p>
<p>在<strong>需要长连接</strong>的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p>
<p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而<code>减少了网络开销</code>，成为了 http 的优点。</p>
<ul>
<li>明文传输</li>
</ul>
<p>即协议里的报文(主要指的是<strong>头部</strong>)不使用二进制数据，而是<strong>文本形式</strong>。<br>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p>
<ul>
<li>队头阻塞问题</li>
</ul>
<p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。</p>
<p><a href="https://juejin.im/post/6844904100035821575" target="_blank" rel="noopener">参考：三元大佬（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p>
<h5 id="HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h5><p><strong>什么是 HTTP 队头阻塞？</strong></p>
<p>HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p>
<ul>
<li>并发连接</li>
</ul>
<p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，<strong>Chrome 中是 6 个</strong>。</p>
<p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p>
<ul>
<li>域名分片</li>
</ul>
<p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p>
<p>比如 content1.sanyuan.com 、content2.sanyuan.com。</p>
<p>这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>
<h5 id="HTTP-2-有哪些改进？"><a href="#HTTP-2-有哪些改进？" class="headerlink" title="HTTP/2 有哪些改进？"></a>HTTP/2 有哪些改进？</h5><p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p>
<ul>
<li>头部压缩</li>
<li>多路复用</li>
</ul>
<p>当然还有一些颠覆性的功能实现:</p>
<ul>
<li>设置请求优先级</li>
<li>服务器推送</li>
</ul>
<p>这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。</p>
<p><strong>头部压缩</strong></p>
<p>在 HTTP/1.1 及之前的时代，<strong>请求体</strong>一般会有响应的压缩编码过程，通过<code>Content-Encoding</code>头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。</p>
<p>HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：</p>
<ul>
<li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把<strong>索引</strong>(比如0，1，2，…)传给对方即可，对方拿到索引查表就行了。这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829193029877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<blockquote>
<p>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个”:”前缀，用来和其它请求头区分开。</p>
</blockquote>
<ul>
<li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li>
</ul>
<p><strong>多路复用</strong></p>
<p>我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于HTTP 基于<code>请求-响应</code>的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p>
<p>后面我们又讨论到用<strong>并发连接</strong>和<strong>域名分片</strong>的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p>
<p>而 HTTP/2 便从 HTTP 协议本身解决了<code>队头阻塞</code>问题。注意，这里并不是指的<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code>，两者并不是一回事。TCP 的队头阻塞是在<code>数据包</code>层面，单位是<code>数据包</code>，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 <code>HTTP 请求-响应</code>层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p>
<p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p>
<p><strong>二进制分帧</strong></p>
<p>首先，HTTP/2 认为<strong>明文传输对机器而言太麻烦</strong>了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输<code>01</code>串，方便了机器的解析。</p>
<p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆<strong>乱序的二进制帧</strong>。这些二进制帧不存在先后关系，因此也就<code>不会排队等待，也就没有了 HTTP 的队头阻塞问题</code>。</p>
<p>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫做<code>流(Stream)</code>。HTTP/2 用<code>流</code>来在<strong>一个 TCP 连接上来进行多个数据帧的通信</strong>，这就是多路复用的概念。</p>
<blockquote>
<p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p>
</blockquote>
<p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<code>请求报文</code>和<code>响应报文</code>。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。</p>
<p><strong>服务器推送</strong></p>
<p>另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它<strong>也能新建 stream 来给客户端发送消息</strong>，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，<code>减少客户端的等待</code>。</p>
<p><strong>总结</strong></p>
<p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如<strong>请求头、URI、状态码、头部字段</strong>都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在<code>TLS</code> 上面的了。最后放一张分层图给大家参考:</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829194312962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h5 id="HTTP-2-中的二进制帧是如何设计的？"><a href="#HTTP-2-中的二进制帧是如何设计的？" class="headerlink" title="HTTP/2 中的二进制帧是如何设计的？"></a>HTTP/2 中的二进制帧是如何设计的？</h5><p><strong>帧结构</strong></p>
<p>HTTP/2 中传输的帧结构如下图所示:<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829194349165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>每个帧分为<strong>帧头</strong>和<strong>帧体</strong>。先是三个字节的帧长度，这个长度表示的是<code>帧体</code>的长度。</p>
<p>然后是帧类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧用来存放 HTTP 报文，控制帧用来管理<code>流</code>的传输。</p>
<p>接下来的一个字节是<strong>帧标志</strong>，里面一共有 8 个标志位，常用的有 <strong>END_HEADERS</strong>表示头数据结束，<strong>END_STREAM</strong>表示单方向数据发送结束。</p>
<p>后 4 个字节是<code>Stream ID</code>, 也就是<code>流标识符</code>，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p>
<p><strong>流的状态变化</strong></p>
<p>从前面可以知道，在 HTTP/2 中，所谓的<code>流</code>，其实就是二进制帧的<strong>双向传输的序列</strong>。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？<br>HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的<code>请求-响应过程</code>为例来说明：</p>
<p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200829194937124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时<strong>客户端的流打开</strong>, <strong>服务端接收之后服务端的流也打开</strong>，两端的流都打开之后，就可以互相传递数据帧和控制帧了。</p>
<p>当客户端要关闭时，向服务端发送<code>END_STREAM帧</code>，进入<strong>半关闭状态</strong>, 这个时候客户端<code>只能接收数据，而不能发送数据</code>。</p>
<p>服务端收到这个<code>END_STREAM帧</code>后也进入半关闭状态，不过此时服务端的情况是<strong>只能发送数据，而不能接收数据</strong>。随后服务端也向客户端发送<code>END_STREAM帧</code>，表示<strong>数据发送完毕，双方进入关闭状态</strong>。</p>
<p>如果下次要开启新的流，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 <code>0 ~ 2的 31 次方</code>，大约 21 亿个。</p>
<p><strong>流的特性</strong></p>
<p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下流传输的特性:</p>
<ul>
<li>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现<strong>多路复用</strong>的基础。</li>
<li>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li>
<li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为<code>发送方</code>或者<code>接收方</code>。</li>
<li>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li>
</ul>
<h4 id="自己搭的博客目的是什么？主要写的内容是？"><a href="#自己搭的博客目的是什么？主要写的内容是？" class="headerlink" title="自己搭的博客目的是什么？主要写的内容是？"></a>自己搭的博客目的是什么？主要写的内容是？</h4><blockquote>
<p>爱折腾，搭建了一个美化版的博客，主要整合前端相关知识点</p>
</blockquote>
<h4 id="询问了大学里面图像处理课程"><a href="#询问了大学里面图像处理课程" class="headerlink" title="询问了大学里面图像处理课程"></a>询问了大学里面图像处理课程</h4><blockquote>
<p>博客专栏里面有图像处理相关博文，问到了这个点</p>
</blockquote>
<h4 id="如何学习前端（或者说是如何学习计算机领域知识）"><a href="#如何学习前端（或者说是如何学习计算机领域知识）" class="headerlink" title="如何学习前端（或者说是如何学习计算机领域知识）"></a>如何学习前端（或者说是如何学习计算机领域知识）</h4><blockquote>
<p>先学好本科基础知识，锻炼思维，然后经常逛一些博客网站，例如掘金，学习优秀的人是怎样学习的，看一些书籍，比如js红宝书。另外，常逛一些b站学习一些老师教授的课程。</p>
</blockquote>
<h4 id="对未来的职业规划"><a href="#对未来的职业规划" class="headerlink" title="对未来的职业规划"></a>对未来的职业规划</h4><blockquote>
<p>热爱前端，干到退休（苦笑）往架构方向发展，然后面试官提到了是否未来会参与算法、人工智能相关领域。我非常赞同，也提了nodejs目前比较火热，后续也会继续学习 koa、egg框架，总之，懂的越多，不懂得更多，一直学习~</p>
</blockquote>
<h4 id="有什么问题可以询问"><a href="#有什么问题可以询问" class="headerlink" title="有什么问题可以询问"></a>有什么问题可以询问</h4><p>了解部门主要业务工作，了解部门规模</p>
<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><blockquote>
<p>感受：问题能想起来的暂时这么多，一面体验还是不错的，又增加了一些知识，还能和面试官交流一下大学学习课程，挺好的。</p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Yang Chao Yi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yangchaoyi.vip/posts/20200812/">https://yangchaoyi.vip/posts/20200812/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yangchaoyi.vip" target="_blank">超逸の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/">字节跳动</a><a class="post-meta__tags" href="/tags/%E7%A7%8B%E6%8B%9B/">秋招</a><a class="post-meta__tags" href="/tags/%E8%AE%B8%E6%84%BFoffer/">许愿offer</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200809222241.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/2020812/"><img class="next-cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200811200159.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「斑愿称为最肝」小狮子前端知识食谱 / 生日之际，好运分享 / 秋招和你手摸手入大厂【史上最全指北】</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/520521/" title="【春招&实习&秋招】前端学习の优质资料整理&心路历程（已上岸）"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200615170126.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-15</div><div class="relatedPosts_title">【春招&实习&秋招】前端学习の优质资料整理&心路历程（已上岸）</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2020611/" title="【字节跳动】前端一面面经"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200610161905.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-11</div><div class="relatedPosts_title">【字节跳动】前端一面面经</div></div></a></div><div class="relatedPosts_item"><a href="/posts/200610/" title="【字节跳动】前端面试准备（一）"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200610161905.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-10</div><div class="relatedPosts_title">【字节跳动】前端面试准备（一）</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2020621/" title="【恒生电子】2021实习（前端） 笔试&面试分享"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200621211610.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-22</div><div class="relatedPosts_title">【恒生电子】2021实习（前端） 笔试&面试分享</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2020616/" title="【深信服】星耀实习生（前端开发）笔试&面试分享"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200616220441.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-16</div><div class="relatedPosts_title">【深信服】星耀实习生（前端开发）笔试&面试分享</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2020612/" title="【建议前端必刷】 用 js 刷LeetCode 算法专题（全）"><img class="relatedPosts_cover" data-src="https://cdn.jsdelivr.net/gh/chocolate1999/cdn/img/20200612194016.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-12</div><div class="relatedPosts_title">【建议前端必刷】 用 js 刷LeetCode 算法专题（全）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"><span class="slider"></span></label><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'MyJU2hPYwmGOX83xvElhQWR1-MdYXbMMI',
      appKey: 'ceIoRkQFQY9lYi6NDekB5v4Y',
      placeholder: '小狮子，留下你的足迹吧（↑邮箱必填），你也可以在右上角切换Gitalk评论~',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      requiredFields: requiredFields,
      master: '00b6017552f79cce0e8d634fdfb77d05',
      friends: '0c164af184c4f776d83b0e98f08b5767,7bf23e76ba3518b54eab1821a6821eb1,d36ba977a9765379c3e78d1a59701319,ac4376986fcb5a84e17f47b641c50a69,d06adebbcbaa24413cc1b53dc8576ed0',
      tagMeta: ["博主","小伙伴","访客"]
    });
  }
  loadScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || true) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div><div class="comments-items-2" data-name="Gitalk"><div id="gitalk-container"></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>function loadGitalk () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)

  loadScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', function () {
    var gitalk = new Gitalk({
      clientID: 'fbfdeac3b5cb0daad093',
      clientSecret: 'daa19d006003e415e226613ebb71a8c1d885b4b3',
      repo: 'chocolate1999.github.io',
      owner: 'Chocolate1999',
      admin: ['Chocolate1999'],
      id: md5(decodeURI(location.pathname)),
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  })

  function commentCount(n){
    try {
      document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
    } catch (e) {
      return false
    }
  }
}

if ('Valine' === 'Gitalk' || true) {
  window.addEventListener('load', loadGitalk)
}
else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Yang Chao Yi</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>湘ICP备20002952号</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/third-party/Valine.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":120,"height":260},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>